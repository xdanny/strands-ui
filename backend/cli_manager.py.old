import asyncio
import json
import uuid
from datetime import datetime
from pathlib import Path
from typing import Optional, Callable, Dict, Any
import aiofiles


class StrandsCLISession:
    """Manages a single Strands CLI subprocess session"""

    def __init__(self, session_id: str, storage_path: Path):
        self.session_id = session_id
        self.storage_path = storage_path
        self.process: Optional[asyncio.subprocess.Process] = None
        self.output_callbacks: list[Callable] = []
        self.transcript: list[Dict[str, Any]] = []
        self.created_at = datetime.now().isoformat()
        self.is_running = False

    async def start(self, command: str = "strands", args: list[str] = None):
        """Start the Strands CLI process"""
        if self.is_running:
            raise RuntimeError("Session already running")

        cmd = [command]
        if args:
            cmd.extend(args)

        # Get the project root directory (parent of backend)
        import os
        project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

        # Start CLI in interactive mode from project root
        self.process = await asyncio.create_subprocess_exec(
            *cmd,
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=project_root,  # Run from project root
        )

        self.is_running = True

        # Start background tasks to read output
        asyncio.create_task(self._read_stdout())
        asyncio.create_task(self._read_stderr())

        # Log session start
        await self._log_event("session_start", {"command": " ".join(cmd)})

    async def _read_stdout(self):
        """Read and process stdout from CLI"""
        if not self.process or not self.process.stdout:
            return

        while self.is_running:
            try:
                line = await self.process.stdout.readline()
                if not line:
                    break

                decoded = line.decode('utf-8').rstrip()
                await self._handle_output("stdout", decoded)
            except Exception as e:
                await self._handle_output("error", f"Error reading stdout: {str(e)}")
                break

    async def _read_stderr(self):
        """Read and process stderr from CLI"""
        if not self.process or not self.process.stderr:
            return

        while self.is_running:
            try:
                line = await self.process.stderr.readline()
                if not line:
                    break

                decoded = line.decode('utf-8').rstrip()
                await self._handle_output("stderr", decoded)
            except Exception as e:
                await self._handle_output("error", f"Error reading stderr: {str(e)}")
                break

    async def _handle_output(self, stream: str, content: str):
        """Process output from CLI"""
        event = {
            "type": stream,
            "content": content,
            "timestamp": datetime.now().isoformat(),
            "session_id": self.session_id
        }

        # Add to transcript
        self.transcript.append(event)

        # Save to file
        await self._save_transcript()

        # Notify all callbacks
        for callback in self.output_callbacks:
            try:
                await callback(event)
            except Exception as e:
                print(f"Error in output callback: {e}")

    async def _log_event(self, event_type: str, data: Dict[str, Any]):
        """Log a session event"""
        event = {
            "type": event_type,
            "data": data,
            "timestamp": datetime.now().isoformat(),
            "session_id": self.session_id
        }
        self.transcript.append(event)
        await self._save_transcript()

    async def send_input(self, text: str):
        """Send input to the CLI process"""
        if not self.process or not self.process.stdin:
            raise RuntimeError("Process not running")

        await self._log_event("user_input", {"content": text})

        self.process.stdin.write(f"{text}\n".encode('utf-8'))
        await self.process.stdin.drain()

    async def stop(self):
        """Stop the CLI process"""
        if not self.is_running:
            return

        self.is_running = False

        if self.process:
            try:
                self.process.terminate()
                await asyncio.wait_for(self.process.wait(), timeout=5.0)
            except asyncio.TimeoutError:
                self.process.kill()
                await self.process.wait()

        await self._log_event("session_end", {})
        await self._save_transcript()

    def add_output_callback(self, callback: Callable):
        """Add a callback to be notified of output events"""
        self.output_callbacks.append(callback)

    def remove_output_callback(self, callback: Callable):
        """Remove an output callback"""
        if callback in self.output_callbacks:
            self.output_callbacks.remove(callback)

    async def _save_transcript(self):
        """Save transcript to disk"""
        session_dir = self.storage_path / self.session_id
        session_dir.mkdir(parents=True, exist_ok=True)

        transcript_file = session_dir / "transcript.json"
        async with aiofiles.open(transcript_file, 'w') as f:
            await f.write(json.dumps({
                "session_id": self.session_id,
                "created_at": self.created_at,
                "transcript": self.transcript
            }, indent=2))

    async def load_transcript(self):
        """Load transcript from disk"""
        transcript_file = self.storage_path / self.session_id / "transcript.json"
        if not transcript_file.exists():
            return

        async with aiofiles.open(transcript_file, 'r') as f:
            content = await f.read()
            data = json.loads(content)
            self.transcript = data.get("transcript", [])
            self.created_at = data.get("created_at", self.created_at)


class CLIManager:
    """Manages multiple Strands CLI sessions"""

    def __init__(self, storage_path: str = "./sessions"):
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)
        self.sessions: Dict[str, StrandsCLISession] = {}

    def create_session(self) -> StrandsCLISession:
        """Create a new CLI session"""
        session_id = str(uuid.uuid4())
        session = StrandsCLISession(session_id, self.storage_path)
        self.sessions[session_id] = session
        return session

    def get_session(self, session_id: str) -> Optional[StrandsCLISession]:
        """Get an existing session"""
        return self.sessions.get(session_id)

    async def list_sessions(self) -> list[Dict[str, Any]]:
        """List all saved sessions"""
        sessions = []
        for session_dir in self.storage_path.iterdir():
            if session_dir.is_dir():
                transcript_file = session_dir / "transcript.json"
                if transcript_file.exists():
                    async with aiofiles.open(transcript_file, 'r') as f:
                        content = await f.read()
                        data = json.loads(content)
                        sessions.append({
                            "session_id": data["session_id"],
                            "created_at": data["created_at"],
                            "message_count": len(data["transcript"])
                        })
        return sorted(sessions, key=lambda x: x["created_at"], reverse=True)

    async def load_session(self, session_id: str) -> Optional[StrandsCLISession]:
        """Load a session from disk"""
        session = StrandsCLISession(session_id, self.storage_path)
        await session.load_transcript()
        return session if session.transcript else None
